import json
import logging
from functools import cached_property
from pathlib import Path
from typing import (
    Optional,
    ClassVar,
    Type,
)

from langchain_core.callbacks import CallbackManagerForToolRun
from openai.types import FunctionDefinition
from openai.types.beta import FunctionTool, AssistantToolParam
from pydantic import model_validator, computed_field, BaseModel, Field
from pyparsing import ParseException
from rdflib import Graph
from rdflib.plugins.sparql import prepareQuery
from typing_extensions import Self

from .base import BaseGraphDBTool


class SparqlQueryTool(BaseGraphDBTool):
    """
    Tool, which executes SPARQL queries generated by the agent.
    The ontology schema, which should be used, can be provided
    either with a path to a file in turtle format containing the ontology schema statements,
    or with a SPARQL CONSTRUCT query, which returns all the ontology schema statements.
    If you're using a well known ontology such as the schema.org ontology, the FOAF ontology, the Wikidata ontology,
    you can omit the :param ontology_schema_file_path and the :param ontology_schema_query,
    and modify the default tool specific instructions to include something like
    "The ontology schema to use in SPARQL queries is the schema.org ontology."
    """

    class SearchInput(BaseModel):
        query: str = Field(
            description="A valid SPARQL SELECT, CONSTRUCT or DESCRIBE query including all prefixes from the ontology"
        )

    name: str = "sparql_query"
    description: str = "Query GraphDB by SPARQL SELECT, CONSTRUCT or DESCRIBE and return result."
    args_schema: Type[BaseModel] = SearchInput
    function_tool: ClassVar[AssistantToolParam] = FunctionTool(
        type="function",
        function=FunctionDefinition(
            name=name,
            description=description,
            parameters={
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "A valid SPARQL SELECT, CONSTRUCT or DESCRIBE query including all "
                                       "prefixes from the ontology"
                    }
                },
                "required": [
                    "query"
                ],
                "additionalProperties": False,
            },
        )
    )
    ontology_schema_file_path: Optional[Path] = None
    ontology_schema_query: Optional[str] = None

    @model_validator(mode="after")
    def valid_ontology_query(self) -> Self:
        """
        Validate the query is a valid SPARQL CONSTRUCT query
        """

        if self.ontology_schema_query:
            try:
                parsed_query = prepareQuery(self.ontology_schema_query)
            except ParseException as e:
                raise ValueError("Ontology query is not a valid SPARQL query.", e)

            if parsed_query.algebra.name != "ConstructQuery":
                raise ValueError(
                    "Invalid query type. Only CONSTRUCT queries are supported."
                )

        return self

    @model_validator(mode="after")
    def validate(self) -> Self:
        if self.ontology_schema_file_path and self.ontology_schema_query:
            raise ValueError(
                "Expected only one of ontology schema file path or ontology schema query. Both are provided."
            )
        return self

    @computed_field
    @cached_property
    def schema_graph(self) -> Optional[Graph]:
        if self.ontology_schema_query:
            logging.debug("Configuring the ontology schema with query.")
            schema_graph = Graph().parse(
                data=self.graph.eval_sparql_query(self.ontology_schema_query, validation=False),
                format="turtle",
            )
            logging.debug(f"Collected {len(schema_graph)} ontology schema statements.")
            return schema_graph
        elif self.ontology_schema_file_path:
            logging.debug("Configuring the ontology schema with file.")
            schema_graph = Graph().parse(
                data=self.ontology_schema_file_path.read_text(),
                format="turtle",
            )
            logging.debug(f"Collected {len(schema_graph)} ontology schema statements.")
            return schema_graph
        else:
            return None

    def _run(
            self,
            query: str,
            run_manager: Optional[CallbackManagerForToolRun] = None,
    ) -> str:
        logging.debug(f"Executing generated SPARQL query {query}")
        query_results = self.graph.eval_sparql_query(query)
        return json.dumps(query_results, indent=2)
